---
title: "Analysis of Citibike Performance of eBikes vs Other Modes"
output: html_notebook
---

First, load all necessary packages.
```{r}
library(tidyverse)
library("dplyr")                  # Load dplyr package
# library("plyr")                 # Load plyr package
# library("readr")                # Load readr package
# library("purrr")                # Load purrr package
# install.packages("data.table")  # Install data.table package
# library("data.table")           # Load data.table package for fread
# install.packages("geosphere")   # Install geosphere package
#library("geosphere")             # Load geosphere package for distance calculation

# This part is to install the most updated package for "revgeo" directly from the developer
# Install the devtools package
# install.packages('devtools') 
# Detach the package already installed (if applicable); otherwise installing from github won't work
# detach("package:revgeo", unload = TRUE) 
# library(devtools)
# install_github('mhudecheck/revgeo')
# library("revgeo")
library(ggplot2)

# Prepare a color palette. Here with R color brewer:
library(RColorBrewer)
myPalette <- brewer.pal(5, "Set2")

# install.packages('ggbump')
library('ggbump')
```
Next, create a pie chart of total Citibike rides (classic vs eBike)
```{r}
tot_rides_classic = as.numeric(table(CB_Data$rideable_type)[1])
tot_rides_electric = as.numeric(table(CB_Data$rideable_type)[2])

jpeg(filename="Visualizations/classic_vs_electric.jpg",width=1400,height=1200)
pie(c(tot_rides_classic, tot_rides_electric), 
    labels = c("Classic","Electric"), border="white", 
    col=c("blue","green"),
    cex=5)
dev.off()
```
Now, track the usage of classic vs eBikes over the course of the year
```{r}
# https://datavizpyr.com/bump-plot-with-ggbump/

# Need this to be numeric for the bump plot to execute properly
axis_bins = c(1:12)

# These shall be used as the x axis labels
time_series = c("May 2021", "Jun 2021", "Jul 2021", "Aug 2021", 
                "Sep 2021", "Oct 2021,", "Nov 2021", "Dec 2021", 
                "Jan 2022", "Feb 2022", "Mar 2022", "Apr 2022")

# Sloppy, but only, way to properly acquire data for the time frame of the study
series_classic = c(
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2021" & month == "5", year)),
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2021" & month == "6", year)),
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2021" & month == "7", year)),
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2021" & month == "8", year)),
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2021" & month == "9", year)),
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2021" & month == "10", year)),
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2021" & month == "11", year)),
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2021" & month == "12", year)),
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2022" & month == "1", year)),
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2022" & month == "2", year)),
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2022" & month == "3", year)),
nrow(subset(CB_Data, rideable_type == "Classic Bike" & year == "2022" & month == "4", year))
)

# Sloppy, but only, way to properly acquire data for the time frame of the study
series_electric = c(
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2021" & month == "5", year)),
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2021" & month == "6", year)),
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2021" & month == "7", year)),
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2021" & month == "8", year)),
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2021" & month == "9", year)),
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2021" & month == "10", year)),
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2021" & month == "11", year)),
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2021" & month == "12", year)),
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2022" & month == "1", year)),
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2022" & month == "2", year)),
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2022" & month == "3", year)),
nrow(subset(CB_Data, rideable_type == "Electric Bike" & year == "2022" & month == "4", year))
)

# Creata data frame
CB_usage_trend <- tibble(Time = axis_bins,
                        Classic = series_classic,
                        Electric = series_electric)

# Then pivot it
CB_usage_long <- CB_usage_trend %>%
  pivot_longer(-Time, names_to = "Type", values_to="Rides" )
 
# Create the geometric bump plot and customize it
CB_usage_long %>%
  ggplot(aes(Time, Rides, color = Type)) +
  geom_point(size = 10) +
  geom_bump() +
  scale_y_continuous(labels = scales::comma) +
  scale_x_continuous(breaks = 1:12,
                     labels = time_series) +
  scale_color_manual(values = c("blue", "green")) +
  theme(text = element_text(size = 20))
ggsave("Visualizations/bump_plot_ggbump.png", width=21, height=9)
```
Now, calculate actual duration of ride (in minutes) as well as year and month.
```{r}
setDT(CB_Data)[, year := format(as.Date(started_at), "%Y") ]
setDT(CB_Data)[, month := format(as.Date(started_at), "%m") ]
CB_Data$duration = as.numeric(
                              difftime(
                                CB_Data$ended_at, 
                                CB_Data$started_at, 
                                units ="mins"
                                )
                              )
head(CB_Data)
```
Figure out the distances being traveled. Since calculating actual roadmap distance through Google Maps or Bing require use of APIs that cost money and place limitations on daily computations, that process shall be forgone in favor of "as the crow flies", which will provide a rough estimate of travel distance in order to figure out speed.

Convert meters to miles.
```{r}
# https://stackoverflow.com/questions/49532911/calculate-distance-longitude-latitude-of-multiple-in-dataframe-r
CB_Data$distance <- 0.000621371 * distHaversine(
                              cbind(CB_Data$start_lng, CB_Data$start_lat), 
                              cbind(CB_Data$end_lng, CB_Data$end_lat) 
                              )
head(CB_Data)
```
Find the zip codes associated with the coordinate data. This will help with ascertaining neighborhood and borough locations for simplicity.
```{r}
CB_Data$start_zip <- revgeo(CB_Data$start_lng, CB_Data$start_lat,
                            provider = NULL, API = NULL, output = "hash",
                            item = "zip")
CB_Data$end_zip <- revgeo(CB_Data$end_lng, CB_Data$end_lat,
                            provider = NULL, API = NULL, output = "hash",
                            item = "zip")
# start_zip <- revgeo(-73.95772, 40.77863,
#                             provider = NULL, API = NULL, output = "hash",
#                             item = "zip")
# end_zip <- revgeo(-73.95578, 40.77280,
#                             provider = NULL, API = NULL, output = "hash",
#                             item = "zip")
# start_zip
# end_zip

head(CB_Data)
```

